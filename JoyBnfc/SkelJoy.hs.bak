module SkelJoy where

-- Haskell module generated by the BNF converter

import AbsJoy
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transCharacterConstant :: CharacterConstant -> Result
transCharacterConstant x = case x of
  CharacterConstant string -> failure x
transAtomicSymbol :: AtomicSymbol -> Result
transAtomicSymbol x = case x of
  AtomicSymbol string -> failure x
transJoyFile :: JoyFile -> Result
transJoyFile x = case x of
  JoyFile cycles -> failure x
transReservedCharacter :: ReservedCharacter -> Result
transReservedCharacter x = case x of
  ReservedCharacter1 -> failure x
  ReservedCharacter2 -> failure x
  ReservedCharacter3 -> failure x
  ReservedCharacter4 -> failure x
  ReservedCharacter5 -> failure x
  ReservedCharacter6 -> failure x
transIntegerConstant :: IntegerConstant -> Result
transIntegerConstant x = case x of
  IntegerConstant1 integer -> failure x
  IntegerConstantInteger integer -> failure x
transFloatConstant :: FloatConstant -> Result
transFloatConstant x = case x of
  FloatConstant1 double -> failure x
  FloatConstantDouble double -> failure x
transReservedWord :: ReservedWord -> Result
transReservedWord x = case x of
  ReservedWord1 -> failure x
  ReservedWord_MODULE -> failure x
  ReservedWord_PRIVATE -> failure x
  ReservedWord_PUBLIC -> failure x
  ReservedWord_END -> failure x
  ReservedWord_HIDE -> failure x
  ReservedWord_IN -> failure x
  ReservedWord_DEFINE -> failure x
  ReservedWord_LIBRA -> failure x
transFactor :: Factor -> Result
transFactor x = case x of
  FactorAtomicSymbol atomicsymbol -> failure x
  FactorIntegerConstant integerconstant -> failure x
  FactorFloatConstant floatconstant -> failure x
  FactorCharacterConstant characterconstant -> failure x
  FactorString string -> failure x
  Factor1 intorcharconstants -> failure x
  Factor2 factors -> failure x
transIntOrCharConstant :: IntOrCharConstant -> Result
transIntOrCharConstant x = case x of
  IntOrCharConstantIntegerConstant integerconstant -> failure x
  IntOrCharConstantCharacterConstant characterconstant -> failure x
transLiteral :: Literal -> Result
transLiteral x = case x of
  Literal_true -> failure x
  Literal_false -> failure x
  Literal1 factors -> failure x
transDefinition :: Definition -> Result
transDefinition x = case x of
  SimpleDef simpledefinition -> failure x
  CompoundDef compounddefinition -> failure x
transSimpleDefinition :: SimpleDefinition -> Result
transSimpleDefinition x = case x of
  SimpleDefinition atomicsymbol literal -> failure x
transCompoundDefinition :: CompoundDefinition -> Result
transCompoundDefinition x = case x of
  CompoundDefinition maybemodule maybeprivate maybepublic possibleendings -> failure x
transPossibleEndings :: PossibleEndings -> Result
transPossibleEndings x = case x of
  PeriodEnd -> failure x
  EndEnd -> failure x
transMaybeModule :: MaybeModule -> Result
transMaybeModule x = case x of
  Module atomicsymbol -> failure x
  NoModule -> failure x
transMaybePrivate :: MaybePrivate -> Result
transMaybePrivate x = case x of
  Private definitions -> failure x
  NoPrivate -> failure x
transMaybePublic :: MaybePublic -> Result
transMaybePublic x = case x of
  Public publiceq definitions -> failure x
  NoPublic -> failure x
transPublicEQ :: PublicEQ -> Result
transPublicEQ x = case x of
  PublicEQ_DEFINE -> failure x
  PublicEQ_LIBRA -> failure x
  PublicEQ_PUBLIC -> failure x
transCycle :: Cycle -> Result
transCycle x = case x of
  DefCycle compounddefinition -> failure x
  FactorCycle factors possibleendings -> failure x

