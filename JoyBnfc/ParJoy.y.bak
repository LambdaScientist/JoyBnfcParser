-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParJoy where
import AbsJoy
import LexJoy
import ErrM

}

%name pJoyFile JoyFile
%name pReservedCharacter ReservedCharacter
%name pIntegerConstant IntegerConstant
%name pFloatConstant FloatConstant
%name pReservedWord ReservedWord
%name pFactor Factor
%name pIntOrCharConstant IntOrCharConstant
%name pListIntOrCharConstant ListIntOrCharConstant
%name pListFactor ListFactor
%name pLiteral Literal
%name pDefinition Definition
%name pListDefinition ListDefinition
%name pSimpleDefinition SimpleDefinition
%name pCompoundDefinition CompoundDefinition
%name pPossibleEndings PossibleEndings
%name pMaybeModule MaybeModule
%name pMaybePrivate MaybePrivate
%name pMaybePublic MaybePublic
%name pPublicEQ PublicEQ
%name pCycle Cycle
%name pListCycle ListCycle
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '-' { PT _ (TS _ 1) }
  '.' { PT _ (TS _ 2) }
  ';' { PT _ (TS _ 3) }
  '==' { PT _ (TS _ 4) }
  'DEFINE' { PT _ (TS _ 5) }
  'END' { PT _ (TS _ 6) }
  'HIDE' { PT _ (TS _ 7) }
  'IN' { PT _ (TS _ 8) }
  'LIBRA' { PT _ (TS _ 9) }
  'MODULE' { PT _ (TS _ 10) }
  'PRIVATE' { PT _ (TS _ 11) }
  'PUBLIC' { PT _ (TS _ 12) }
  '[' { PT _ (TS _ 13) }
  ']' { PT _ (TS _ 14) }
  'false' { PT _ (TS _ 15) }
  'true' { PT _ (TS _ 16) }
  '{' { PT _ (TS _ 17) }
  '}' { PT _ (TS _ 18) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_CharacterConstant { PT _ (T_CharacterConstant $$) }
L_AtomicSymbol { PT _ (T_AtomicSymbol $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
CharacterConstant    :: { CharacterConstant} : L_CharacterConstant { CharacterConstant ($1)}
AtomicSymbol    :: { AtomicSymbol} : L_AtomicSymbol { AtomicSymbol ($1)}

JoyFile :: { JoyFile }
JoyFile : ListCycle { AbsJoy.JoyFile (reverse $1) }
ReservedCharacter :: { ReservedCharacter }
ReservedCharacter : '[' { AbsJoy.ReservedCharacter1 }
                  | ']' { AbsJoy.ReservedCharacter2 }
                  | '{' { AbsJoy.ReservedCharacter3 }
                  | '}' { AbsJoy.ReservedCharacter4 }
                  | ';' { AbsJoy.ReservedCharacter5 }
                  | '.' { AbsJoy.ReservedCharacter6 }
IntegerConstant :: { IntegerConstant }
IntegerConstant : '-' Integer { AbsJoy.IntegerConstant1 $2 }
                | Integer { AbsJoy.IntegerConstantInteger $1 }
FloatConstant :: { FloatConstant }
FloatConstant : '-' Double { AbsJoy.FloatConstant1 $2 }
              | Double { AbsJoy.FloatConstantDouble $1 }
ReservedWord :: { ReservedWord }
ReservedWord : '==' { AbsJoy.ReservedWord1 }
             | 'MODULE' { AbsJoy.ReservedWord_MODULE }
             | 'PRIVATE' { AbsJoy.ReservedWord_PRIVATE }
             | 'PUBLIC' { AbsJoy.ReservedWord_PUBLIC }
             | 'END' { AbsJoy.ReservedWord_END }
             | 'HIDE' { AbsJoy.ReservedWord_HIDE }
             | 'IN' { AbsJoy.ReservedWord_IN }
             | 'DEFINE' { AbsJoy.ReservedWord_DEFINE }
             | 'LIBRA' { AbsJoy.ReservedWord_LIBRA }
Factor :: { Factor }
Factor : AtomicSymbol { AbsJoy.FactorAtomicSymbol $1 }
       | IntegerConstant { AbsJoy.FactorIntegerConstant $1 }
       | FloatConstant { AbsJoy.FactorFloatConstant $1 }
       | CharacterConstant { AbsJoy.FactorCharacterConstant $1 }
       | String { AbsJoy.FactorString $1 }
       | '{' ListIntOrCharConstant '}' { AbsJoy.Factor1 (reverse $2) }
       | '[' ListFactor ']' { AbsJoy.Factor2 (reverse $2) }
IntOrCharConstant :: { IntOrCharConstant }
IntOrCharConstant : IntegerConstant { AbsJoy.IntOrCharConstantIntegerConstant $1 }
                  | CharacterConstant { AbsJoy.IntOrCharConstantCharacterConstant $1 }
ListIntOrCharConstant :: { [IntOrCharConstant] }
ListIntOrCharConstant : {- empty -} { [] }
                      | ListIntOrCharConstant IntOrCharConstant { flip (:) $1 $2 }
ListFactor :: { [Factor] }
ListFactor : {- empty -} { [] }
           | ListFactor Factor { flip (:) $1 $2 }
Literal :: { Literal }
Literal : 'true' { AbsJoy.Literal_true }
        | 'false' { AbsJoy.Literal_false }
        | ListFactor { AbsJoy.Literal1 (reverse $1) }
Definition :: { Definition }
Definition : SimpleDefinition { AbsJoy.SimpleDef $1 }
           | CompoundDefinition { AbsJoy.CompoundDef $1 }
ListDefinition :: { [Definition] }
ListDefinition : {- empty -} { [] }
               | Definition { (:[]) $1 }
               | Definition ';' ListDefinition { (:) $1 $3 }
SimpleDefinition :: { SimpleDefinition }
SimpleDefinition : AtomicSymbol '==' Literal { AbsJoy.SimpleDefinition $1 $3 }
CompoundDefinition :: { CompoundDefinition }
CompoundDefinition : MaybeModule MaybePrivate MaybePublic PossibleEndings { AbsJoy.CompoundDefinition $1 $2 $3 $4 }
PossibleEndings :: { PossibleEndings }
PossibleEndings : '.' { AbsJoy.PeriodEnd }
                | 'END' { AbsJoy.EndEnd }
MaybeModule :: { MaybeModule }
MaybeModule : 'MODULE' AtomicSymbol { AbsJoy.Module $2 }
            | {- empty -} { AbsJoy.NoModule }
MaybePrivate :: { MaybePrivate }
MaybePrivate : 'PRIVATE' ListDefinition { AbsJoy.Private $2 }
             | {- empty -} { AbsJoy.NoPrivate }
MaybePublic :: { MaybePublic }
MaybePublic : PublicEQ ListDefinition { AbsJoy.Public $1 $2 }
            | {- empty -} { AbsJoy.NoPublic }
PublicEQ :: { PublicEQ }
PublicEQ : 'DEFINE' { AbsJoy.PublicEQ_DEFINE }
         | 'LIBRA' { AbsJoy.PublicEQ_LIBRA }
         | 'PUBLIC' { AbsJoy.PublicEQ_PUBLIC }
Cycle :: { Cycle }
Cycle : CompoundDefinition { AbsJoy.DefCycle $1 }
      | ListFactor PossibleEndings { AbsJoy.FactorCycle (reverse $1) $2 }
ListCycle :: { [Cycle] }
ListCycle : {- empty -} { [] } | ListCycle Cycle { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

